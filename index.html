<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Google Summer of Code 2016 by mronian</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Google Summer of Code 2016</h1>
        <p class="header">Looking back at the eventful summer!</p>

        <ul>
          <li class="download"><a class="buttons" href="https://github.com/mronian/gsoc-2016/zipball/master">Download ZIP</a></li>
          <li class="download"><a class="buttons" href="https://github.com/mronian/gsoc-2016/tarball/master">Download TAR</a></li>
          <li><a class="buttons github" href="https://github.com/mronian/gsoc-2016">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/mronian">mronian</a></p>


      </header>
      <section>
        <h1>
<a id="google-summer-of-code-2016---the-julia-language" class="anchor" href="#google-summer-of-code-2016---the-julia-language" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Google Summer of Code 2016 - The Julia Language</h1>

<div align="center">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/69/Julia_prog_language.svg/2000px-Julia_prog_language.svg.png" alt="Julia Logo" width="210" height="142" align="middle">
</div>

<p><sub><a href="#before-the-coding-period">Before the Coding Period</a> | <a href="#summary-of-contributions">Summary of Contributions</a> | <a href="#exposure-correction">Exposure Correction</a> | <a href="#feature-extraction">Feature Extraction</a> | <a href="#drawing-on-images">Drawing on Images</a> | <a href="#miscellaneous">Miscelleanous</a> | <a href="#future-work">Future Work</a></sub></p>

<p>Whew. What an amazing summer it has been! It seems like just yesterday that I found myself among the lucky students who were selected for GSoC 2016. To make the news even more amazing, along with me 14 other students had been selected from my college! The efforts of previous GSoC alumni like <a href="https://github.com/hargup">Harsh</a> and <a href="https://github.com/abhishek-kakkar">Abhishek</a> to spread the culture of open source programming seemed to have paid off as this was a far cry from earlier years when only a handful of people used to participate. I can't thank both of them enough for helping me draft my proposal and giving valuable suggestions.</p>

<p>My <a href="https://docs.google.com/document/d/1XD_fpT6YpyK6Iv2Rues2RlU-15l4aBbUZTSz1V216pw/edit?usp=sharing">proposal</a> for this summer was to work on <a href="https://github.com/JuliaImages/ImageFeatures.jl">ImageFeatures.jl</a>, a new Julia package for Feature Extraction and Descriptors in Images. Alongside this, I planned to add Exposure Correction functionality to <a href="https://github.com/timholy/Images.jl">Images.jl</a>, an existing package for Image Processing in Julia.</p>

<p>One of the fun moments of the summer was getting a chance to attend JuliaCon 2016 at MIT, Boston! The Julia Language had generously invited all GSoCers to come and present their projects. My talk can be viewed below. Although I messed up the slides a bit and wasn't prepared for the talk, overall I guess it wasn't too shabby ;)</p>

<div align="center">

</div>

<p>As we reach the final week of GSoC, it feels great to have managed to achieve most of my goals for the summer and gotten the chance to work with amazing people in the <a href="https://github.com/JuliaImages">JuliaImages</a> organisation as we attempt to develop a full fledged Computer Vision library of which ImageFeatures.jl is an essential part. I hope to continue to work and contribute more packages above and beyond GSoC as we slowly build up the organisation.</p>

<p>I would like to thank my mentors <a href="https://github.com/timholy">Tim Holy</a> and <a href="https://github.com/SimonDanisch">Simon Danisch</a> for helping me out throughout the summer and guiding me towards achieving my goals. Their friendliness and approachability made the summer a enjoyable and fruitful experience.</p>

<h2>
<a id="before-the-coding-period" class="anchor" href="#before-the-coding-period" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Before the Coding Period</h2>

<h3>
<a id="testimagesjl" class="anchor" href="#testimagesjl" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>TestImages.jl</h3>

<p>In the initial phase of drafting my proposal, I had played around with Images.jl and TestImages.jl to understand the packages and try to make some initial contributions to the same. In the process, I felt that TestImages.jl needed a proper documentation along with a guide for contributing test images. Apart from the documentation, there was also a need to store the test images in a proper repository so that the links would not expire. Once my proposal was selected, I started working on this and with help from Tim Holy, I developed a new website for TestImages.jl along with an improved API to easily download images from the repository. The new API checks if the requested image is present in the online repository if it is not found locally and downloads it for the user.</p>

<p>The documentation can be viewed <a href="https://timholy.github.io/TestImages.jl">here</a>.</p>

<h3>
<a id="histograms" class="anchor" href="#histograms" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Histograms</h3>

<p>To get familiar with open source and Images.jl, one of my first PRs was to add the histogram functionality. This was a very simple function which would calculate the histogram of an image i.e. the intensity distribution.</p>

<div class="highlight highlight-source-julia"><pre>edges, count <span class="pl-k">=</span> <span class="pl-c1">imhist</span>(img, nbins)
edges, count <span class="pl-k">=</span> <span class="pl-c1">imhist</span>(img, nbins, minval, maxval)</pre></div>

<p>This generates a histogram for the image over <code>nbins</code> spread between <code>(minval, maxval]</code>. If <code>minval</code> and <code>maxval</code> are not given, then the minimum and maximum values present in the image are taken. <code>edges</code> specifies the range of the bins while <code>count</code> is a vector of the individual counts of the bins.</p>

<h2>
<a id="summary-of-contributions" class="anchor" href="#summary-of-contributions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Summary of Contributions</h2>

<table>
<thead>
<tr>
<th>Package</th>
<th>Merged Commits</th>
<th>Pull Requests (Open and Merged)</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/timholy/Images.jl">Images.jl</a></td>
<td><a href="https://github.com/timholy/Images.jl/commits/master?author=mronian">Link</a></td>
<td><a href="https://github.com/timholy/Images.jl/pulls?utf8=%E2%9C%93&amp;q=is%3Apr%20author%3Amronian%20">Link</a></td>
</tr>
<tr>
<td><a href="https://github.com/JuliaImages/ImageFeatures.jl">ImageFeatures.jl</a></td>
<td><a href="https://github.com/JuliaImages/ImageFeatures.jl/commits/master?author=mronian">Link</a></td>
<td><a href="https://github.com/JuliaImages/ImageFeatures.jl/pulls?utf8=%E2%9C%93&amp;q=is%3Apr%20author%3Amronian%20">Link</a></td>
</tr>
<tr>
<td><a href="https://github.com/JuliaImages/ImageDraw.jl">ImageDraw.jl</a></td>
<td><a href="https://github.com/JuliaImages/ImageDraw.jl/commits/master?author=mronian">Link</a></td>
<td><a href="https://github.com/JuliaImages/ImageDraw.jl/pulls?utf8=%E2%9C%93&amp;q=is%3Apr%20author%3Amronian%20">Link</a></td>
</tr>
<tr>
<td><a href="https://github.com/timholy/TestImages.jl">TestImages.jl</a></td>
<td><a href="https://github.com/timholy/TestImages.jl/commits/master?author=mronian">Link</a></td>
<td><a href="https://github.com/timholy/TestImages.jl/pulls?utf8=%E2%9C%93&amp;q=is%3Apr%20author%3Amronian%20">Link</a></td>
</tr>
<tr>
<td><a href="https://github.com/JuliaGraphics/ColorVectorSpace.jl">ColorVectorSpace.jl</a></td>
<td><a href="https://github.com/JuliaGraphics/ColorVectorSpace.jl/commits/master?author=mronian">Link</a></td>
<td><a href="https://github.com/JuliaGraphics/ColorVectorSpace.jl/pulls?utf8=%E2%9C%93&amp;q=is%3Apr%20author%3Amronian%20">Link</a></td>
</tr>
<tr>
<td><a href="https://github.com/JuliaGraphics/ColorTypes.jl">ColorTypes.jl</a></td>
<td><a href="https://github.com/JuliaGraphics/ColorTypes.jl/commits/master?author=mronian">Link</a></td>
<td><a href="https://github.com/JuliaGraphics/ColorTypes.jl/pulls?utf8=%E2%9C%93&amp;q=is%3Apr%20author%3Amronian%20">Link</a></td>
</tr>
</tbody>
</table>

<h2>
<a id="exposure-correction" class="anchor" href="#exposure-correction" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Exposure Correction</h2>

<p>The first part of my proposal was to add exposure correction functionality to Images.jl. This was a bit challenging considering the various type of Images and ColorTypes in julia and my goal was to provide a common API which would handle all types of Images using julia's method dispatch. I am happy to say that we were able to do this to a considerable extent and all the functions are easy to use and intuitive, offering a lot of options at the same time.</p>

<h3>
<a id="histogram-equalisation" class="anchor" href="#histogram-equalisation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Histogram Equalisation</h3>

<p>My first contribution during the coding period was the histogram equalisation functionality. This took up quite a bit of time as I worked on optimising the performance and got to learn about the inner workings of Arrays (Images are derived from Arrays!) in julia and how to write efficient functions for operating on them.  I was also introduced to <code>@code_warntype</code> and how to julia infers the type of variables in the code and how to best exploit this to increase performance. Tim Holy was really helpful and patient (Thanks Tim!) throughout the initial phase with a lot of code reviews and advice which really helped me later on.</p>

<div class="highlight highlight-source-julia"><pre>hist_equalised_img <span class="pl-k">=</span> <span class="pl-c1">histeq</span>(img, nbins)
hist_equalised_img <span class="pl-k">=</span> <span class="pl-c1">histeq</span>(img, nbins, minval, maxval)</pre></div>

<p>This returns a histogram equalised image with a granularity of approximately <code>nbins</code> number of bins. If <code>minval</code> and <code>maxval</code> are specified then intensities are equalized to the range <code>(minval, maxval)</code>. The default values are <code>0</code> and <code>1</code>.</p>

<h3>
<a id="histogram-matching" class="anchor" href="#histogram-matching" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Histogram Matching</h3>

<p>Histogram matching is another way of achieving exposure correction by trying to modify the histogram of the image to match that of a predefined image with the desired histogram.</p>

<div class="highlight highlight-source-julia"><pre>hist_matched_img <span class="pl-k">=</span> <span class="pl-c1">histmatch</span>(img, oimg, nbins)</pre></div>

<p>This returns a grayscale histogram matched image with a granularity of <code>nbins</code> number of bins. <code>img</code> is the image to be matched and <code>oimg</code> is the image having the desired histogram to be matched to.</p>

<h3>
<a id="gamma-correction" class="anchor" href="#gamma-correction" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Gamma Correction</h3>

<p>Gamma correction is a method of enhancing or reducing the intensity levels in an image by using a power function.</p>

<div class="highlight highlight-source-julia"><pre>gamma_corrected_img <span class="pl-k">=</span> <span class="pl-c1">adjust_gamma</span>(img, gamma)</pre></div>

<p>The <code>adjust_gamma</code> function can handle a variety of input types. The returned image depends on the input type. If the input is an <code>Image</code> then the resulting image is of the same type and has the same properties.</p>

<h3>
<a id="contrast-limited-adaptive-histogram-equalisation" class="anchor" href="#contrast-limited-adaptive-histogram-equalisation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Contrast Limited Adaptive Histogram Equalisation</h3>

<p>An advanced version of histogram equalisation, it differs from ordinary histogram equalization in the respect that the adaptive method computes several histograms, each corresponding to a distinct section of the image, and uses them to redistribute the lightness values of the image. It is therefore suitable for improving the local contrast and enhancing the definitions of edges in each region of an image.</p>

<p>In the straightforward form, CLAHE is done by calculation a histogram of a window around each pixel and using the transformation function of the equalised histogram to rescale the pixel. Since this is computationally expensive, we use interpolation which gives a significant rise in efficiency without compromising the result. The image is divided into a grid and equalised histograms are calculated for each block. Then, each pixel is interpolated using the closest histograms.</p>

<div class="highlight highlight-source-julia"><pre>hist_equalised_img <span class="pl-k">=</span> <span class="pl-c1">clahe</span>(img, nbins, xblocks <span class="pl-k">=</span> <span class="pl-c1">8</span>, yblocks <span class="pl-k">=</span> <span class="pl-c1">8</span>, clip <span class="pl-k">=</span> <span class="pl-c1">3</span>)</pre></div>

<p>The <code>xblocks</code> and <code>yblocks</code> specify the number of blocks to divide the input image into in each direction. <code>nbins</code> specifies the granularity of histogram calculation of each local region. <code>clip</code> specifies the value at which the histogram is clipped. The excess in the histogram bins with value exceeding <code>clip</code> is redistributed among the other bins.</p>

<h2>
<a id="feature-extraction" class="anchor" href="#feature-extraction" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Feature Extraction</h2>

<p>After working on exposure correction, I began with the other major chunk of my proposal which was ImageFeatures.jl. Edge and corner detection was already a part of Images.jl so I added some of my work in the same to Images.jl itself (this will be moved to ImageFeatures.jl before release). </p>

<h3>
<a id="canny-edge-detection" class="anchor" href="#canny-edge-detection" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Canny Edge Detection</h3>

<p>The canny edge detector works by finding intensity gradients of an image and then double thresholding pixels as being part of weak or strong edges. Then the weak edges not connected to any strong edge are discarded and the result has the edges detected in the image.</p>

<div class="highlight highlight-source-julia"><pre>canny_edges <span class="pl-k">=</span> <span class="pl-c1">canny</span>(img, sigma <span class="pl-k">=</span> <span class="pl-c1">1.4</span>, upperThreshold <span class="pl-k">=</span> <span class="pl-c1">0.80</span>, lowerThreshold <span class="pl-k">=</span> <span class="pl-c1">0.20</span>)</pre></div>

<p>Results of using the Canny edge detector on an image.</p>

<p><img src="https://github.com/mronian/gsoc-2016/blob/master/canny_example.jpg?raw=true" alt=""></p>

<h3>
<a id="corner-detection" class="anchor" href="#corner-detection" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Corner Detection</h3>

<p>I worked on the <code>imcorner</code> API to overhaul the existing corner detection functions and added additional functionality with 
<code>kitchen_rosenfeld</code> corners and FAST corners (discussed below). </p>

<div class="highlight highlight-source-julia"><pre>corners <span class="pl-k">=</span> <span class="pl-c1">imcorner</span>(img; [method])
corners <span class="pl-k">=</span> <span class="pl-c1">imcorner</span>(img, threshold, percentile; [method])</pre></div>

<p>The <code>method</code> argument takes in the name of the algorithm to be used to detect corners, namely <code>harris</code>, <code>shi_tomasi</code> and <code>kitchen_rosenfeld</code>.</p>

<h3>
<a id="fast-corners" class="anchor" href="#fast-corners" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>FAST Corners</h3>

<p>FAST (Features from Accelerated Segment Test) corners, an efficient and very popular corner detection algorithm works by finding a contiguous set of pixels brighter or darker than the candidate pixel. Depending on the number of contiguous pixels found, the candidate is marked as a potential corner. </p>

<p>FAST corners may be detected by using the <code>fastcorners</code> API.</p>

<div class="highlight highlight-source-julia"><pre>corners <span class="pl-k">=</span> <span class="pl-c1">fastcorners</span>(img, n, threshold)</pre></div>

<p>Results of using the FAST Corner detector on an image.</p>

<p><img src="https://github.com/mronian/gsoc-2016/blob/master/fast_example.jpg?raw=true" alt=""></p>

<h3>
<a id="imagefeaturesjl" class="anchor" href="#imagefeaturesjl" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ImageFeatures.jl</h3>

<p>I started work on ImageFeatures.jl by adding texture matching descriptors like GLCMs (Gray Level Co-occurence Matrix) and LBPs (Local Binary Patterns). </p>

<h3>
<a id="gray-level-co-occurence-matrices" class="anchor" href="#gray-level-co-occurence-matrices" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Gray Level Co Occurence Matrices</h3>

<p>Gray Level Co-occurrence Matrix (GLCM) is used for texture analysis. We consider two pixels at a time, called the reference and the neighbour pixel. We define a particular spatial relationship between the reference and neighbour pixel before calculating the GLCM.</p>

<p>The GLCM is calculated by calling one of <code>glcm</code>, <code>glcm_symmetric</code> or <code>glcm_norm</code> functions depending on the desired GLCM type. </p>

<div class="highlight highlight-source-julia"><pre>glcm <span class="pl-k">=</span> <span class="pl-c1">glcm</span>(img, distance, angle, mat_size)</pre></div>

<p>If multiple GLCMs need to be calculated, the same function may be used by passing a vector in the arguments. The <code>distance</code> and <code>angle</code> arguments take in both <code>Int</code> and <code>Vector{Int}</code> values.</p>

<p>Multiple properties of the obtained GLCM can be calculated by using the <code>glcm_prof</code> function which calculates the property of the entire matrix or in windows if given the window dimensions.</p>

<div class="highlight highlight-source-julia"><pre>prop <span class="pl-k">=</span> <span class="pl-c1">glcm_prop</span>(glcm, property)
prop <span class="pl-k">=</span> <span class="pl-c1">glcm_prop</span>(glcm, height, width, property)</pre></div>

<p>Various properties can be calculated like <code>mean</code>, <code>variance</code>, <code>correlation</code>, <code>contrast</code>, <code>IDM</code> (Inverse Difference Moment), <code>ASM</code> (Angular Second Moment), <code>entropy</code>, <code>max_prob</code> (Max Probability), <code>energy</code> and <code>dissimilarity</code>.</p>

<h3>
<a id="local-binary-patterns" class="anchor" href="#local-binary-patterns" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Local Binary Patterns</h3>

<p>Local Binary Pattern (LBP) is a very efficient texture operator which labels the pixels of an image by thresholding the neighborhood of each pixel and considers the result as a binary number. The feature vector can now then be processed using some machine-learning algorithm to classify images. Such classifiers are often used for face recognition or texture analysis.</p>

<p>We have multiple type of LBP algorithms in ImageFeatures.jl :</p>

<p>The first three methods can be used with both circular offsets (circle around the pixel) or the 8x8 neighbourhood.</p>

<p>The first two methods, <code>lbp</code> and <code>modified_lbp</code> may be called with one of three <code>lbp_original</code>, <code>lbp_uniform</code> and <code>lbp_rotation_invariant</code> as the <code>method</code> argument which specifies the method used to create the bit pattern.</p>

<ul>
<li>
<code>lbp</code> is the original algorithm defined in the `94 paper.</li>
<li>
<code>modified_lbp</code> is a version of LBP which compares the intensity of each pixel with the average intensity in the window.</li>
<li>
<code>direction_coded_lbp</code> is a version of LBP where the intensity differences along the four directions (N-S, NW-SE, NE-SW, E-W) are coded along with the variation in differences along the directions in 8 bits.</li>
<li>
<code>multi_block_lbp</code> is a version of LBP used for window matching as an alternative to Haar like features. The image is divided into blocks and the average intensity of each block is considered with the center block to obtain the LBP.</li>
</ul>

<div class="highlight highlight-source-julia"><pre>lbp_image <span class="pl-k">=</span> <span class="pl-c1">lbp</span>(img)
lbp_image <span class="pl-k">=</span> <span class="pl-c1">lbp</span>(img, <span class="pl-c1">10</span>, <span class="pl-c1">2</span>) <span class="pl-c"># With circular offsets</span>
lbp_image <span class="pl-k">=</span> <span class="pl-c1">lbp</span>(img_gray, lbp_uniform)
lbp_image <span class="pl-k">=</span> <span class="pl-c1">lbp</span>(img_gray, lbp_rotation_invariant)


lbp_image <span class="pl-k">=</span> <span class="pl-c1">modified_lbp</span>(img_gray)
lbp_image <span class="pl-k">=</span> <span class="pl-c1">modified_lbp</span>(img_gray, points, radius)

lbp_image <span class="pl-k">=</span> <span class="pl-c1">direction_coded_lbp</span>(img)
lbp_image <span class="pl-k">=</span> <span class="pl-c1">direction_coded_lbp</span>(img, points, radius)

pattern <span class="pl-k">=</span> <span class="pl-c1">multi_block_lbp</span>(img, top_left_y, top_left_x, height_block, width_block)</pre></div>

<p>We can also create the descriptor from a histogram of LBPs over the image by calling <code>create_descriptor</code>.</p>

<div class="highlight highlight-source-julia"><pre>desc <span class="pl-k">=</span> <span class="pl-c1">create_descriptor</span>(img, yblocks, xblocks, [lbp_type])</pre></div>

<p>The <code>lbp_type</code> argument takes in one of the functions defined above, while the <code>yblocks</code> and <code>xblocks</code> arguments specify the size of the grid to create in the image.</p>

<h3>
<a id="framework" class="anchor" href="#framework" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Framework</h3>

<p>Before starting with the feature descriptors, we decided on a easy to use common API which could be used with all the algorithms. </p>

<p>The <code>Feature</code> and <code>Keypoint</code> types are the fundamental types in ImageFeatures.jl. <code>Feature</code> stores the <code>keypoint</code> and its <code>orientation</code> and <code>scale</code>. A vector of the <code>Feature</code> type is denoted by the <code>Features</code> type and similary a vector of <code>Keypoint</code> type is denoted by the <code>Keypoints</code> type. We provide multiple methods for easily transitioning between the two types. </p>

<p><code>Keypoints</code> or <code>Features</code> can be generate from an image of boolean values by <code>Keypoints(boolean_image)</code> or <code>Features(boolean_image)</code> where the boolean_image may be obtained from a feature detection algorithm for eg. the result of a corner detector. All feature detectors in ImageFeatures.jl directly return <code>Features</code>.</p>

<p>A keypoint may be converted to a feature or vice versa by directly passing it to the respective method eg. <code>Keypoint(feature_A)</code> or <code>Feature(keypoint_A)</code>.</p>

<p>The algorithms in ImageFeatures.jl are to be used by calling the <code>extract_features</code> and <code>create_descriptor</code> APIs.</p>

<div class="highlight highlight-source-julia"><pre>keypoints <span class="pl-k">=</span> <span class="pl-c1">extract_features</span>(img, params)</pre></div>

<p>The <code>params</code> argument is dependent on the algorithm chosen and its type is the name of the algorithm. For eg. <code>censure_params &lt;: CENSURE</code></p>

<div class="highlight highlight-source-julia"><pre>descriptor, ret_keypoints <span class="pl-k">=</span> <span class="pl-c1">create_descriptor</span>(img, params)
descriptor, ret_keypoints <span class="pl-k">=</span> <span class="pl-c1">create_descriptor</span>(img, keypoints, params)</pre></div>

<p>Depending on the algorithm , the <code>create_descriptor</code> API can be used to directly create a feature descriptor from the image (eg. ORB, BRISK) or from the keypoints (eg. BRIEF, FREAK). In case of the latter, the keypoints can be obtained using algorithms such as FAST or CENSURE. The <code>params</code> argument is dependent on the algorithm chosen and its type is the name of the algorithm. For eg. <code>brief_params &lt;: BRIEF</code></p>

<p>A brief discussion on the various algorithms is given below. For more details on each of the algorithms and the parameters of the constructor methods, please visit the <a href="http://juliaimages.github.io/ImageFeatures.jl/latest/">documentation</a> for ImageFeatures.jl.</p>

<h3>
<a id="brief-descriptors" class="anchor" href="#brief-descriptors" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>BRIEF Descriptors</h3>

<p>BRIEF (Binary Robust Independent Elementary Features) is an efficient feature point descriptor. It is highly discriminative even when using relatively few bits and is computed using simple intensity difference tests. BRIEF does not have a predefined sampling pattern and the pairs are chosen randomly.</p>

<div class="highlight highlight-source-julia"><pre>brief_params <span class="pl-k">=</span> <span class="pl-c1">BRIEF</span>([size], [window], [sigma], [sampling_type], [seed])
desc, ret_keypoints <span class="pl-k">=</span> <span class="pl-c1">create_descriptor</span>(img, keypoints, brief_params)</pre></div>

<p>Results of using the BRIEF descriptor on a translated image.</p>

<p><img src="http://juliaimages.github.io/ImageFeatures.jl/latest/tutorials/brief_example.jpg" alt=""></p>

<h3>
<a id="orb-keypoints-and-descriptors" class="anchor" href="#orb-keypoints-and-descriptors" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ORB Keypoints and Descriptors</h3>

<p>ORB (Oriented Fast and Rotated Brief) descriptor is similar to BRIEF but has an orientation detection mechanism. Apart from creating a descriptor, it also extracts keypoints over a gaussian pyramid using the FAST corners algorithm.</p>

<p>It can be used by calling the ORB constructor method. </p>

<div class="highlight highlight-source-julia"><pre>orb_params <span class="pl-k">=</span> <span class="pl-c1">ORB</span>([num_keypoints], [n_fast], [threshold], [harris_factor], [downsample], [levels], [sigma])
desc, ret_keypoints <span class="pl-k">=</span> <span class="pl-c1">create_descriptor</span>(img, orb_params)</pre></div>

<p>Results of using the ORB descriptor on a translated and rotated image.</p>

<p><img src="http://juliaimages.github.io/ImageFeatures.jl/latest/tutorials/orb_example.jpg" alt=""></p>

<h3>
<a id="censure-keypoints" class="anchor" href="#censure-keypoints" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>CENSURE Keypoints</h3>

<p><em>Note : This PR is still open. The function needs more tests before it can be merged.</em></p>

<p>CENSURE (CENter SURround Extremas) keypoints are calculated using extremas at all scales and locations unlike SIFT or SURF which take extremas at each octave. To approximate the Laplacian operator, a bi-level (1 or -1) centre surround filter is used. Increasing size of the filter in each octave gives the result of the operator at different scales. Points of maxima and minima across the octaves are extracted as keypoints.</p>

<div class="highlight highlight-source-julia"><pre>censure_params <span class="pl-k">=</span> <span class="pl-c1">CENSURE</span>([smallest], [largest], [filter], [response_threshold], [line_threshold])
keypoints <span class="pl-k">=</span> <span class="pl-c1">extract_features</span>(img, censure_params)</pre></div>

<h3>
<a id="brisk-descriptors" class="anchor" href="#brisk-descriptors" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>BRISK Descriptors</h3>

<p>The BRISK (Binary Robust Invariant Scalable Keypoints) descriptor has a predefined sampling pattern as compared to BRIEF or ORB. Pixels are sampled over concentric rings. </p>

<p>The BRISK descriptor can be used by calling the BRISK constructor method to define the parameters and then using it with the <code>create_descriptor</code> API. </p>

<div class="highlight highlight-source-julia"><pre>brisk_params <span class="pl-k">=</span> <span class="pl-c1">BRISK</span>([pattern_scale])
desc, ret_keypoints <span class="pl-k">=</span> <span class="pl-c1">create_descriptor</span>(img, keypoints, brisk_params)</pre></div>

<p>Results of using the BRISK descriptor on a translated and rotated image.</p>

<p><img src="http://juliaimages.github.io/ImageFeatures.jl/latest/tutorials/brisk_example.jpg" alt=""></p>

<h3>
<a id="freak-descriptors" class="anchor" href="#freak-descriptors" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>FREAK Descriptors</h3>

<p>The FREAK (Fast REtinA Keypoint) descriptor, similar to BRISK as a predefined sampling pattern. It uses a retinal sampling grid with more density of points near the centre with the density decreasing exponentially with distance from the centre.</p>

<p>The FREAK descriptor can be used by calling the FREAK constructor method to define the parameters and then using it with the <code>create_descriptor</code> API. Unlike BRISK, FREAK does not calculate the keypoints.</p>

<div class="highlight highlight-source-julia"><pre>freak_params <span class="pl-k">=</span> <span class="pl-c1">FREAK</span>([pattern_scale])
desc, ret_keypoints <span class="pl-k">=</span> <span class="pl-c1">create_descriptor</span>(img, keypoints, freak_params)</pre></div>

<p>Results of using the FREAK descriptor on a translated and rotated image.</p>

<p><img src="http://juliaimages.github.io/ImageFeatures.jl/latest/tutorials/freak_example.jpg" alt=""></p>

<h2>
<a id="drawing-on-images" class="anchor" href="#drawing-on-images" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Drawing on Images</h2>

<p>To help me understand how the feature detection algorithms were working, I needed a drawing library for Images in julia. Since it was already on the roadmap for JuliaImages, I developed proper APIs and created a new package, <a href="https://github.com/JuliaImages/ImageDraw.jl">ImageDraw.jl</a>. </p>

<h3>
<a id="lines" class="anchor" href="#lines" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Lines</h3>

<p>The <code>line</code> and <code>line!</code> functions draw a line on the input image given the points p1, p2 as CartesianIndex{2} with the given <code>color</code>. Lines are drawn using the <code>bresenham</code> method by default. If anti-aliasing is required, the <code>xiaolin_wu</code> can be used. </p>

<div class="highlight highlight-source-julia"><pre>img_with_line <span class="pl-k">=</span> <span class="pl-c1">line</span>(img, p1, p2, color, method)
img_with_line <span class="pl-k">=</span> <span class="pl-c1">line</span>(img, y0, x0, y1, x1, color, method)</pre></div>

<p>To draw a line on the input image itself, use the line! function.</p>

<div class="highlight highlight-source-julia"><pre><span class="pl-c1">line!</span>(img, p1, p2, color, method)</pre></div>

<h3>
<a id="circles-and-ellipses" class="anchor" href="#circles-and-ellipses" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Circles and Ellipses</h3>

<p>The <code>ellipse</code> and <code>ellipse!</code> (similar use as <code>line!</code>) draw an ellipse on the input image given the <code>center</code> as a <code>CartesianIndex{2}</code> or as coordinates <code>(y, x)</code> using the specified <code>color</code>. If <code>color</code> is not specified, <code>one(eltype(img))</code> is used.</p>

<div class="highlight highlight-source-julia"><pre>img_with_ellipse <span class="pl-k">=</span> <span class="pl-c1">ellipse</span>(img, center, radiusy, radiusx)
img_with_ellipse <span class="pl-k">=</span> <span class="pl-c1">ellipse</span>(img, center, color, radiusy, radiusx)
img_with_ellipse <span class="pl-k">=</span> <span class="pl-c1">ellipse</span>(img, y, x, radiusy, radiusx)
img_with_ellipse <span class="pl-k">=</span> <span class="pl-c1">ellipse</span>(img, y, x, color, radiusy, radiusx)</pre></div>

<p>Similarly the <code>circle</code> and its counterpart <code>circle!</code> functions may be used to draw circles.</p>

<div class="highlight highlight-source-julia"><pre>img_with_circle <span class="pl-k">=</span> <span class="pl-c1">circle</span>(img, center, radiusy, radiusx)
img_with_circle <span class="pl-k">=</span> <span class="pl-c1">circle</span>(img, center, color, radiusy, radiusx)
img_with_circle <span class="pl-k">=</span> <span class="pl-c1">circle</span>(img, y, x, radiusy, radiusx)
img_with_circle <span class="pl-k">=</span> <span class="pl-c1">circle</span>(img, y, x, color, radiusy, radiusx)</pre></div>

<h2>
<a id="miscellaneous" class="anchor" href="#miscellaneous" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Miscellaneous</h2>

<p>Apart from the work discussed above, I also made minor contributions to two related packages, <a href="https://github.com/JuliaGraphics/ColorVectorSpace.jl">ColorVectorSpace.jl</a> and <a href="https://github.com/JuliaGraphics/ColorTypes.jl">ColorTypes.jl</a></p>

<h2>
<a id="future-work" class="anchor" href="#future-work" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Future Work</h2>

<p>I am working on creating a set of tutorials on extracting features and using them to match images. The link to the tutorials can be found at the ImageFeatures.jl documentation <a href="http://juliaimages.github.io/ImageFeatures.jl/latest">website</a>.</p>
      </section>
      <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		
  </body>
</html>
